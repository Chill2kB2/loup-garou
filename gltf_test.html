<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Test GLB (Fox)</title>
  <link rel="icon" href="data:," />
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#07090d;font-family:system-ui,Segoe UI,Arial}
    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      padding:10px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.45);
      color:#eaeef7;font-weight:850;font-size:12px;
      backdrop-filter:blur(10px);
    }
    #hud .mut{color:rgba(234,238,247,.72);display:block;margin-top:6px;white-space:pre-wrap}
  </style>
</head>
<body>
  <div id="hud">
    Test GLB
    <span id="t" class="mut">Chargement…</span>
  </div>

  <script src="three.min.js"></script>
  <script src="GLTFLoader.js"></script>

  <script>
    const t = document.getElementById("t");

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // r146: sRGB output
    if ("outputEncoding" in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07090d);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.05, 800);
    camera.position.set(0, 2.0, 6.0);
    camera.lookAt(0, 1.0, 0);

    // Lights
    scene.add(new THREE.HemisphereLight(0xbfd7ff, 0x0b0d12, 0.9));

    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(10, 18, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    scene.add(sun);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(80,80),
      new THREE.MeshStandardMaterial({color:0x3a4452, roughness:0.95})
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    function applyShadows(root){
      root.traverse(o=>{
        if(o && o.isMesh){
          o.castShadow = true;
          o.receiveShadow = true;
        }
      });
    }

    let mixer = null;
    let modelRoot = null;

    const loader = new THREE.GLTFLoader();
    loader.load(
      "assets/models/test/Fox.glb",
      (gltf) => {
        modelRoot = gltf.scene;
        applyShadows(modelRoot);
        scene.add(modelRoot);

        // FRAME CAMERA AUTOMATIQUE
        const box = new THREE.Box3().setFromObject(modelRoot);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        // recentrer modèle
        modelRoot.position.sub(center);

        // rescale pour ~1.6m de haut
        const h = size.y || 1;
        const s = 1.6 / h;
        modelRoot.scale.setScalar(s);

        // remettre au sol (y >= 0)
        const box2 = new THREE.Box3().setFromObject(modelRoot);
        const minY = box2.min.y;
        modelRoot.position.y -= minY;

        // recalcul après scale/position
        const box3 = new THREE.Box3().setFromObject(modelRoot);
        const sphere = new THREE.Sphere();
        box3.getBoundingSphere(sphere);

        const r = sphere.radius || 1;
        const dist = r * 2.2;

        camera.position.set(sphere.center.x + dist, sphere.center.y + r*0.9, sphere.center.z + dist);
        camera.lookAt(sphere.center);

        // Anim si dispo
        if (gltf.animations && gltf.animations.length){
          mixer = new THREE.AnimationMixer(modelRoot);
          mixer.clipAction(gltf.animations[0]).play();
        }

        t.textContent = "OK: Fox chargé ✅";
      },
      (xhr) => {
        if (xhr && xhr.total) {
          const p = Math.round((xhr.loaded/xhr.total)*100);
          t.textContent = "Téléchargement Fox.glb… " + p + "%";
        }
      },
      (err) => {
        t.textContent = "ERREUR chargement Fox.glb ❌";
      }
    );

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      if (mixer) mixer.update(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
